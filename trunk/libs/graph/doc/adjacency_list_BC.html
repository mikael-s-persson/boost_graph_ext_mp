<HTML>
<!--
     Copyright (c) Sven Mikael Persson 2013
    
     Distributed under the Boost Software License, Version 1.0.
     (See accompanying file LICENSE_1_0.txt or copy at
     http://www.boost.org/LICENSE_1_0.txt)
  -->
<Head>
<Title>Boost Graph Library: Adjacency List (with Boost.Container)</Title>
<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b"
        ALINK="#ff0000">
<IMG SRC="../../../boost.png"
     ALT="C++ Boost" width="277" height="86">

<BR Clear>

<H1><A NAME="sec:adjacency-list-BC-class"></A>
<pre>
adjacency_list_BC&lt;OutEdgeList, VertexList, Directed,
                     VertexProperties, EdgeProperties&gt;
</pre>
</H1>


<P>
The <TT>adjacency_list_BC</TT> class implements a generalized adjacency
list graph structure using Boost.Container containers for vertices and 
edges. The template arguments provide many configuration options so 
that you can pick a version of the class that best meets your needs. An <a
href="graph_theory_review.html#sec:adjacency-list-representation">adjacency-list</a>
is basically a two-dimensional structure, where each element of the
first dimension represents a vertex, and each of the vertices contains
a one-dimensional structure that is its edge list. <a
href="#fig:adj-list-graph">Figure 1</a> shows an adjacency list
representation of a directed graph.

<P></P>
<DIV ALIGN="center"><A NAME="fig:adj-list-graph"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 1:</STRONG> Adjacency List Representation of a Directed Graph.</CAPTION>
<TR><TD><IMG SRC="./figs/adj-matrix-graph2.gif" width="386" height="284"></TD>
<TD><IMG SRC="./figs/adj-list2.gif" width="62" height="122"></TD></TR>
</TABLE>
</DIV><P></P>

The <TT>VertexList</TT> template argument of the <TT>adjacency_list_BC</TT>
class controls what kind of container is used to store the outer
two-dimensional container. The <TT>OutEdgeList</TT> template argument
controls what kind of container is used to store the edge
lists. The choices for <TT>OutEdgeList</TT> and <TT>VertexList</TT> will
determine the space complexity of the graph structure, and will
determine the time complexity of the various graph operations. The
possible choices and tradeoffs are discussed in Section <A
HREF="./using_adjacency_list_BC.html#sec:choosing-graph-type">Choosing
the <TT>OutEdgeList</TT> and <TT>VertexList</TT></A>.

<P>
The <TT>Directed</TT> template argument controls whether the graph is
directed, undirected, or directed with access to both the in-edges and
out-edges (which we call bidirectional). A bidirectional graph or 
undirected graph takes up an additional pointer-size of space per edge, 
as compared to a directed graph, since each edge must be referenced in in-edge lists. 
<a href="#fig:undir-adj-list-graph">Figure 2</a> shows an adjacency list
representation of an undirected graph.

<P></P>
<DIV ALIGN="center"><A NAME="fig:undir-adj-list-graph"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 2:</STRONG> Adjacency List Representation of an Undirected Graph.</CAPTION>
<TR><TD><IMG SRC="./figs/undir-adj-matrix-graph2.gif" width="260" height="240"></TD>
<TD><IMG SRC="./figs/undir-adj-list.gif" width="62" height="122"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
A tutorial on how to use the <TT>adjacency_list_BC</TT> class is in
Section <A HREF="./using_adjacency_list_BC.html">Using
<TT>adjacency_list_BC</TT></A>.

<P>

<P>

<H3>Example</H3>

<P>
The example in <a
href="../example/family-tree-alBC.cpp"><tt>examples/family-tree-alBC.cpp</tt></a>
shows how to represent a family tree with a graph.

<H3>Template Parameters</H3>

<P>
<TABLE border>
<TR>
<th>Parameter</th><th>Description</th><th>Default</th>
</tr>

<TR><TD><TT>OutEdgeList</TT></TD>
<TD>The selector for the container used to represent the edge-list for each of the vertices.</TD>
<TD><TT>vecBC</TT></TD>
</TR>

<TR>
<TD><TT>VertexList</TT></TD>
<TD>The selector for the container used to represent the vertex-list of the graph.</TD>
<TD><TT>vecBC</TT></TD>
</TR>

<TR>
<TD><TT>Directed</TT></TD>
<TD>A selector to choose whether the graph is directed, undirected, or directed with bidirectional edge access (access to both out-edges and in-edges). The options are <TT>directedS</TT>, <TT>undirectedS</TT>, and <TT>bidirectionalS</TT>.</TD>
<TD><TT>directedS</TT></TD>
</TR>

<TR>
<TD><TT>VertexProperties</TT></TD>
<TD>for specifying internal per vertex property storage.</TD>
<TD><TT>no_property</TT></TD>
</TR>

<TR>
<TD><TT>EdgeProperties</TT></TD>
<TD>for specifying internal per edge property storage.</TD>
<TD><TT>no_property</TT></TD>
</TR>

<!--<TR>
<TD><TT>GraphProperties</TT></TD>
<TD>for specifying property storage for the graph object.</TD>
<TD><TT>no_property</TT></TD>
</TR>-->

</TABLE>
<P>

<H3>Model of</H3>

<P>
<a href="./VertexAndEdgeListGraph.html">VertexAndEdgeListGraph</a>,
<a href="./MutablePropertyGraph.html">MutablePropertyGraph</a>,
<a href="../../utility/CopyConstructible.html">CopyConstructible</a>,
<a href="../../utility/Assignable.html">Assignable</a>,
and <a href="../../serialization/doc/index.html">Serializable</a>.


<P>

<H3>Where Defined</H3>

<P>
<a href="../../../boost/graph/adjacency_list_BC.hpp"><TT>boost/graph/adjacency_list_BC.hpp</TT></a><br><br>
Also, the serialization functionality is in
<a href="../../../boost/graph/adj_list_BC_serialize.hpp"><tt>boost/graph/adj_list_BC_serialize.hpp</tt></a>.
<P>

<H3>Implementation Differences with <TT>adjacency_list</TT></H3>

<P>
The <TT>adjacency_list_BC</TT> class is a complete re-write of the <TT>adjacency_list</TT>
class in the sense that it provides an identical set of functionality and can be a 
drop-in replacement for <TT>adjacency_list</TT>, however, the internal mechanics of it
are entirely different, with some notable differences that could affect your code,
but mostly, could affect your decisions about the storage containers.

<P>
The central difference between <tt>adjacency_list</tt> and <tt>adjacency_list_BC</tt> is 
that the latter uses the Boost.Container library for the vertex and edge containers.
The motivation for that difference is the fact that containers in Boost.Container 
allow incomplete types, which standard containers are not required to allow. 
Without this allowance, the implementation of <tt>adjacency_list</tt> is forced 
to introduce additional levels of indirection. Case in point, when the <tt>vecBC</tt> is 
chosen for the <tt>VertexList</tt> argument, the <tt>adjacency_list</tt> implementation
is forced to store vertices in a <tt>std::vector</tt> of pointers to vertices that are 
individually allocated dynamically, which would be considered by some users as an egregious 
breach of contract. Using containers from the Boost.Container library, 
the implementation of <tt>adjacency_list_BC</tt> can reduce indirections to an absolute 
minimum, e.g., vertices are stored by value in a vector container when the user so wishes 
by specifying <tt>vecBC</tt> for the <tt>VertexList</tt> argument.

<P>
Another central difference between the two implementations is that <tt>adjacency_list</tt> was 
originally written to use the <tt>boost::property</tt> class template to construct 
internal properties for vertices and edges. In recent years, the use of that method is 
discouraged in favor of <a href="bundles.html">bundled properties</a>. However, 
the internal mechanics of <tt>adjacency_list</tt> are still entirely oriented 
towards the use <tt>boost::property</tt>, with special mechanisms to allow for 
bundled properties instead, resulting in substantial complications in harmonizing
the two methods. On the other hand, <tt>adjacency_list_BC</tt> is natively geared 
towards the use of bundled properties, with accommodations to allow the use of 
properties formed with <tt>boost::property</tt>. As it turns out, this strategy 
leads to a substantial reduction of complexity in the implementation, improving 
compilation times in general, and reducing the length of compilation error messages.

<P>
The <tt>adjacency_list</tt> has a template argument called <tt>EdgeListS</tt> to
specify the container for a general edge-list. Because the <tt>adjacency_list_BC</tt> 
uses fewer indirections, such a list is completely unnecessary to the implementation,
and that template argument is not needed.

<P>
Another set of differences reside in the time-complexities of the operations on 
the graph. Due to the streamlining of the containers in <tt>adjacency_list_BC</tt>, 
there is, in general, less space complexity throughout, but time complexities are 
sometimes worse and sometimes better, compared to <tt>adjacency_list</tt>.

<P>
Finally, an additional feature of the <tt>adjacency_list_BC</tt> class 
is the option to store vertices or edges in a "pooled" container, via the option 
<tt>boost::poolBC</tt> for either <tt>VertexList</tt> or <tt>OutEdgeList</tt>.
The <tt>poolBC</tt> container option is implemented in a way that is similar to 
pooled allocators in the Boost.Pool library. The elements are stored in a vector 
container in which "holes" are created whenever elements are removed, and 
these holes are re-used whenever elements are added. The advantage of this 
option is that whenever an element is removed from the vector, the other 
elements are not displaced, and thus, descriptors and iterators to all 
other elements remain valid. This translates to significant improvements 
to the time complexity of many operations on the graph. However, the cost 
for these additional benefits is in the form of validity checks required to 
ensure that elements are valid (not a "hole") before accessing them.
<P>


<H2>Vertex and Edge Properties</H2>

<P>
Properties such as color, distance, weight, and user-defined
properties can be attached to the vertices and edges of the graph
using properties. The property values can be read from and written to
via the property maps provided by the graph. The property maps are
obtained via the <TT>get(property, g)</TT> function.  How to use
properties is described in Section <A
HREF="./using_adjacency_list.html#sec:adjacency-list-properties">Internal
Properties </A>. The property maps are objects that implement the
interface defined in Section <A
HREF="../../property_map/doc/property_map.html">Property Map
Concepts</A> or may be <a href="bundles.html">bundled properties</a>,
which have a more succinct syntax. The types of all property values
must be Copy/Move Constructible, Copy/Move Assignable, and Default 
Constructible.
The property maps obtained from the
<TT>adjacency_list_BC</TT> class are models of the <a
href="../../property_map/doc/LvaluePropertyMap.html">Lvalue Property
Map</a> concept. If the <TT>adjacency_list_BC</TT> is const,
then the property map is constant, otherwise the property
map is mutable.

<P>
If the <TT>VertexList</TT> of the graph is <TT>vecBC</TT>, then the
graph has a builtin vertex indices map accessed via the property map for
the <TT>vertex_index_t</TT> property.  The indices fall in the range
<TT>[0, num_vertices(g))</TT> and are contiguous. When a vertex is
removed the indices are adjusted so that they retain these
properties. Some care must be taken when using these indices to access
exterior property storage. The property map for vertex index is a
model of <a href="../../property_map/doc/ReadablePropertyMap.html">Readable
Property Map</a>.

<P>

<h2>Iterator and Descriptor Stability/Invalidation</h2>

Some care must be taken when changing the structure of a graph (via
adding or removing edges). Depending on the type of
<tt>adjacency_list_BC</tt> and on the operation, some of the iterator or
descriptor objects that point into the graph may become invalid.  For
example, the following code will result in undefined (bad) behavior:

<pre>
  typedef adjacency_list_BC&lt;listBC, vecBC&gt; Graph; <b>// VertexList=vecBC</b>
  Graph G(N);
  <b>// Fill in the graph...</b>

  <b>// Attempt to remove all the vertices. Wrong!</b>
  graph_traits&lt;Graph&gt;::vertex_iterator vi, vi_end;
  for (boost::tie(vi, vi_end) = vertices(G); vi != vi_end; ++vi)
    remove_vertex(*vi, G);

  <b>// Remove all the vertices. This is still wrong!</b>
  graph_traits&lt;Graph&gt;::vertex_iterator vi, vi_end, next;
  boost::tie(vi, vi_end) = vertices(G);
  for (next = vi; vi != vi_end; vi = next) {
    ++next;
    remove_vertex(*vi, G);
  }
</pre>

The reason this is a problem is that we are invoking
<tt>remove_vertex()</tt>, which when used with an
<tt>adjacency_list_BC</tt> where <tt>VertexList=vecBC</tt>, invalidates
all iterators and descriptors for the graph (such as <tt>vi</tt> and
<tt>vi_end</tt>), thereby causing trouble in subsequent iterations of
the loop.

<p>

If we use a different kind of <tt>adjacency_list_BC</tt>, where
<tt>VertexList=listBC</tt> or <tt>VertexList=poolBC</tt>, then 
the iterators are not invalidated by calling <tt>remove_vertex</tt> 
unless the iterator is pointing to the actual vertex that was removed. 
The following code demonstrates this.

Here is an example using the <tt>poolBC</tt> container:
<pre>
  typedef adjacency_list_BC&lt;listBC, poolBC&gt; Graph; <b>// VertexList=poolBC</b>
  Graph G(N);
  <b>// Fill in the graph...</b>

  <b>// Attempt to remove all the vertices. This is OK.</b>
  graph_traits&lt;Graph&gt;::vertex_iterator vi, vi_end;
  for (boost::tie(vi, vi_end) = vertices(G); vi != vi_end; ++vi)
    remove_vertex(*vi, G);  // vi remains valid, if not dereferenced again.

  <b>// Remove all the vertices. This is OK.</b>
  graph_traits&lt;Graph&gt;::vertex_iterator vi, vi_end, next;
  boost::tie(vi, vi_end) = vertices(G);
  for (next = vi; vi != vi_end; vi = next) {
    ++next;
    remove_vertex(*vi, G);  // vi remains valid, if not dereferenced again, but 'next' is safer.
  }
</pre>

And here is an example using the <tt>listBC</tt> container:
<pre>
  typedef adjacency_list_BC&lt;listBC, listBC&gt; Graph; <b>// VertexList=listBC</b>
  Graph G(N);
  <b>// Fill in the graph...</b>

  <b>// Attempt to remove all the vertices. Wrong!</b>
  graph_traits&lt;Graph&gt;::vertex_iterator vi, vi_end;
  for (boost::tie(vi, vi_end) = vertices(G); vi != vi_end; ++vi)
    remove_vertex(*vi, G);  // vi is invalidated.

  <b>// Remove all the vertices. This is OK.</b>
  graph_traits&lt;Graph&gt;::vertex_iterator vi, vi_end, next;
  boost::tie(vi, vi_end) = vertices(G);
  for (next = vi; vi != vi_end; vi = next) {
    ++next;
    remove_vertex(*vi, G);  // vi is invalidated, but next is still good.
  }
</pre>

<p>

The stability issue also affects vertex and edge descriptors.  For
example, suppose you use vector of vertex descriptors to keep track of
the parents (or predecessors) of vertices in a shortest paths tree
(see <a href="../example/dijkstra-example.cpp"><tt>examples/dijkstra-example.cpp</tt></a>).
You create the parent vector with a call to
<tt>dijkstra_shortest_paths()</tt>, and then remove a vertex from the
graph. Subsequently you try to use the parent vector, but since all
vertex descriptors have become invalid, the result is incorrect.

<pre>
  std::vector&lt;Vertex&gt; parent(num_vertices(G));
  std::vector&lt;Vertex&gt; distance(num_vertices(G));

  dijkstra_shortest_paths(G, s, distance_map(&amp;distance[0]),
    predecessor_map(&amp;parent[0]));

  remove_vertex(s, G); <b>// Bad idea! Invalidates vertex descriptors in parent vector.</b>

  <b>// The following will produce incorrect results</b>
  for(boost::tie(vi, vend) = vertices(G); vi != vend; ++vi)
    std::cout << p[*vi] << " is the parent of " << *vi << std::endl;
</pre>


<p>
Note that in this discussion, iterator and descriptor invalidation is
concerned with the invalidation of iterators and descriptors that are
<b>not directly affected</b> by the operation. For example, performing
<tt>remove_edge(u, v, g)</tt> will always invalidate any edge
descriptor for <i>(u,v)</i> or edge iterator pointing to <i>(u,v)</i>,
regardless of the kind of <tt>adjacency_list_BC</tt> used.  In this discussion
of iterator and descriptor invalidation, we are only concerned with the
effect of <tt>remove_edge(u, v, g)</tt> on edge descriptors and
iterators that point to other edges (not <i>(u,v)</i>).

<p>
In general, if you want your vertex and edge descriptors to be stable
(never invalidated) then use <tt>poolBC</tt>, <tt>listBC</tt> or <tt>setBC</tt> 
for the <tt>VertexList</tt> and <tt>OutEdgeList</tt> template parameters of
<tt>adjacency_list_BC</tt>. If you are not as concerned about descriptor
and iterator stability, and are more concerned about memory
consumption, locality of reference and graph traversal speed, use <tt>vecBC</tt> 
for the <tt>VertexList</tt> and/or <tt>OutEdgeList</tt> template parameters.

<p>
The following table summarizes which operations cause descriptors and
iterators to become invalid. In the table, <tt>EL</tt> is an
abbreviation for <tt>OutEdgeList</tt> and <tt>VL</tt> means
<tt>VertexList</tt>. The <b>Adj Iter</b> category includes the
<tt>out_edge_iterator</tt>, <tt>in_edge_iterator</tt>, and
<tt>adjacency_iterator</tt> types. A more detailed description of
descriptor and iterator invalidation is given in the documentation for
each operation.

<p>

<table border>
<CAPTION ALIGN="BOTTOM"><STRONG>Table:</STRONG>
    Summary of Descriptor and Iterator Invalidation.
    </CAPTION>
<tr>
    <th>Function</th>
    <th>Vertex Desc</th>
    <th>Edge Desc</th>
    <th>Vertex Iter</th>
    <th>Edge Iter</th>
    <th>Adj Iter</th>
</tr>
<tr>
<td>
    <tt>add_edge()</tt></td>
    <td align=center><tt>OK</tt></td>
    <td align=center><tt>OK</tt></td>
    <td align=center><tt>OK</tt></td>
    <td align=center><tt>OK</tt></td>
    <td align=center><tt>OK</tt></td>
</tr>
<tr>
    <td><tt>remove_edge()<br>remove_edge_if()<br>remove_out_edge_if()<br>
            remove_in_edge_if()<br>clear_vertex()</tt>
    </td>
    <td align=center><tt>OK</tt></td>
    <td align=center><tt>OK</tt></td>
    <td align=center><tt>OK</tt></td>
    <td align=center><tt>EL=vecBC</tt></td>
    <td align=center><tt>EL=vecBC</tt></td>
</tr>
<tr>
    <td><tt>add_vertex()</tt></td>
    <td align=center><tt>OK</tt></td>
    <td align=center><tt>OK</tt></td>
    <td align=center><tt>OK</tt></td>
    <td align=center><tt>OK</tt></td>
    <td align=center><tt>OK</tt></td>
</tr>
<tr>
    <td><tt>remove_vertex()</tt></td>
    <td align=center><tt>VL=vecBC</tt></td>
    <td align=center><tt>VL=vecBC</tt></td>
    <td align=center><tt>VL=vecBC</tt></td>
    <td align=center><tt>VL=vecBC</tt></td>
    <td align=center><tt>VL=vecBC</tt></td>
</tr>
</table>

<H2>Associated Types</H2>

<hr>

<tt>graph_traits&lt;adjacency_list_BC&gt;::vertex_descriptor</tt>
<br><br>
The type for the vertex descriptors associated with the
<TT>adjacency_list_BC</TT>.

<hr>

<tt>graph_traits&lt;adjacency_list_BC&gt;::edge_descriptor</tt>
<br><br>
The type for the edge descriptors associated with the
<TT>adjacency_list_BC</TT>.

<hr>

<tt>graph_traits&lt;adjacency_list_BC&gt;::vertex_iterator</tt>
<br><br>
The type for the iterators returned by <TT>vertices()</TT>.

When <tt>VertexList=vecBC</tt> then the <tt>vertex_iterator</tt> models
<a
href="http://www.sgi.com/tech/stl/RandomAccessIterator.html">RandomAccessIterator</a>. Otherwise
the <tt>vertex_iterator</tt> models <a
href="http://www.sgi.com/tech/stl/BidirectionalIterator.html">BidirectionalIterator</a>.

<hr>

<tt>graph_traits&lt;adjacency_list_BC&gt;::edge_iterator</tt>
<br><br>
The type for the iterators returned by <TT>edges()</TT>.
The <tt>edge_iterator</tt> models <a
href="http://www.sgi.com/tech/stl/BidirectionalIterator.html">BidirectionalIterator</a>.


<hr>


<tt>graph_traits&lt;adjacency_list_BC&gt;::out_edge_iterator</tt>
<br><br>

The type for the iterators returned by <TT>out_edges()</TT>.
When <tt>OutEdgeList=vecBC</tt> and <tt>Directed!=undirectedS</tt> then the <tt>out_edge_iterator</tt> models
<a href="http://www.sgi.com/tech/stl/RandomAccessIterator.html">RandomAccessIterator</a>.  
Otherwise the <tt>out_edge_iterator</tt> models 
<a href="http://www.sgi.com/tech/stl/BidirectionalIterator.html">BidirectionalIterator</a>.

<hr>

<tt>graph_traits&lt;adjacency_list_BC&gt;::adjacency_iterator</tt>
<br><br>
The type for the iterators returned by <TT>adjacent_vertices()</TT>.
The <tt>adjacency_iterator</tt> models the same iterator concept as <tt>out_edge_iterator</tt>.
<hr>

<tt>adjacency_list_BC::inv_adjacency_iterator</tt>
<br><br>
The type for the iterators returned by <TT>inv_adjacent_vertices()</TT>.
The <tt>inv_adjacency_iterator</tt> models the same iterator concept
as <tt>out_edge_iterator</tt>.
<hr>

<tt>graph_traits&lt;adjacency_list_BC&gt;::directed_category</tt><br>
and<br>
<tt>adjacency_list_BC_traits&lt;OutEdgeList, VertexList, Directed&gt;::directed_category</tt>
<br><br>
Provides information about whether the graph is
directed (<TT>directed_tag</TT>) or undirected (<TT>undirected_tag</TT>).

<hr>

<tt>graph_traits&lt;adjacency_list_BC&gt;::edge_parallel_category</tt><br>
and<br>
<tt>adjacency_list_BC_traits&lt;OutEdgeList, VertexList, Directed&gt;::edge_parallel_category</tt>
<br><br>
This describes whether the graph class allows the insertion of
parallel edges (edges with the same source and target). The two tags
are <tt>allow_parallel_edge-_tag</tt> and
<tt>disallow_parallel_edge_tag</tt>. The <tt>setBC</tt>, <tt>unordered_setBC</tt>, 
<tt>mapBC</tt>, and <tt>unordered_mapBC</tt> options for <tt>OutEdgeListS</tt> disallow
parallel edges while the others allow parallel edges.

<hr>

<tt>graph_traits&lt;adjacency_list_BC&gt;::vertices_size_type</tt><br>
and<br>
<tt>adjacency_list_BC_traits&lt;OutEdgeList, VertexList, Directed&gt;::vertices_size_type</tt>
<br><br>
The type used for dealing with the number of vertices in the graph.

<hr>

<tt>graph_traits&lt;adjacency_list_BC&gt;::edge_size_type</tt><br>
and<br>
<tt>adjacency_list_BC_traits&lt;OutEdgeList, VertexList, Directed&gt;::edge_size_type</tt>
<br><br>
The type used for dealing with the number of edges in the graph.

<hr>

<tt>graph_traits&lt;adjacency_list_BC&gt;::degree_size_type</tt>
<br><br>
The type used for dealing with the number of edges incident to a vertex
in the graph.

<hr>

<tt>property_map&lt;adjacency_list_BC, Property&gt;::type</tt><br>
and<br>
<tt>property_map&lt;adjacency_list_BC, Property&gt;::const_type</tt>
<br><br>
The property map type for vertex or edge properties in the graph. The
specific property is specified by the <tt>Property</tt> template argument,
and must match one of the properties specified in the
<tt>VertexProperties</tt> or <tt>EdgeProperties</tt> for the graph.

<!--<hr>

<tt>graph_property&lt;adjacency_list_BC, Property&gt;::type</tt>
<br><br>
The property value type for the graph property specified by the <tt>Property</tt> tag.

--><hr>

<tt>adjacency_list_BC::out_edge_list_selector</tt>
<br><br>
The type <tt>OutEdgeListS</tt>.

<hr>

<tt>adjacency_list_BC::vertex_list_selector</tt>
<br><br>
The type <tt>VertexListS</tt>.

<hr>

<tt>adjacency_list_BC::directed_selector</tt>
<br><br>
The type <tt>DirectedS</tt>.

<hr>

<tt>adjacency_list_BC::vertex_property_type</tt>
<br><br>
The type <tt>VertexProperties</tt> or equivalent (proxy). This is the type expected for 
arguments to functions of the <a href="./MutablePropertyGraph.html">MutablePropertyGraph</a> concept.

<hr>

<tt>adjacency_list_BC::edge_property_type</tt>
<br><br>
The type <tt>EdgeProperties</tt> or equivalent (proxy). This is the type expected for 
arguments to functions of the <a href="./MutablePropertyGraph.html">MutablePropertyGraph</a> concept.

<hr>

<H2>Member Functions</H2>

<hr>

<pre>
adjacency_list_BC()
</pre>
Default constructor. Creates an empty graph object with zero vertices
and zero edges.

<hr>

<pre>
adjacency_list_BC(const&nbsp;adjacency_list_BC&amp;&nbsp;x)
</pre>
Copy constructor. Creates a new graph that is a copy of graph
<tt>x</tt>, including the edges, vertices, and properties.

<hr>

<pre>
adjacency_list_BC(adjacency_list_BC&amp;&amp;&nbsp;x)
</pre>
Move constructor (C++11). Moves the contents of the <tt>x</tt> graph 
into a new graph.

<hr>

<pre>
adjacency_list_BC&amp; operator=(const&nbsp;adjacency_list_BC&amp;&nbsp;x)
</pre>
Assignment operator. Makes this graph a copy of graph
<tt>x</tt>, including the edges, vertices, and properties.

<hr>

<pre>
adjacency_list_BC&amp; operator=(adjacency_list_BC&amp;&amp;&nbsp;x)
</pre>
Move-assignment operator. Moves the contents of the <tt>x</tt> graph 
into this graph.

<hr>

<!--<pre>
adjacency_list_BC(vertices_size_type&nbsp;n)
</pre>
Creates a graph object with <TT>n</TT> vertices and zero edges.

<hr>

<a name="sec:iterator-constructor">
<pre>
template &lt;class&nbsp;EdgeIterator&gt;
adjacency_list_BC(EdgeIterator&nbsp;first, EdgeIterator&nbsp;last,
                  vertices_size_type&nbsp;n,
                  edges_size_type&nbsp;m = 0)
</pre>
Creates a graph object with <TT>n</TT> vertices and with the edges
specified in the edge list given by the range <TT>[first, last)</TT>.
The <tt>EdgeIterator</tt> must be a model of <a
href="http://www.sgi.com/tech/stl/InputIterator.html">InputIterator</a>.
The value type of the <TT>EdgeIterator</TT> must be a
<TT>std::pair</TT>, where the type in the pair is an integer type. The
integers will correspond to vertices, and they must all fall in the
range of <TT>[0, n)</TT>.
</a>

<hr>

<pre>
template &lt;class&nbsp;EdgeIterator, class&nbsp;EdgePropertyIterator&gt;
adjacency_list_BC(EdgeIterator&nbsp;first, EdgeIterator&nbsp;last,
                  EdgePropertyIterator&nbsp;ep_iter,
                  vertices_size_type&nbsp;n,
                  edges_size_type&nbsp;m = 0)
</pre>
Creates a graph object with <TT>n</TT> vertices and with the edges
specified in the edge list given by the range <TT>[first, last)</TT>.
The <tt>EdgeIterator</tt> and <tt>EdgePropertyIterator</tt> must be a
model of <a
href="http://www.sgi.com/tech/stl/InputIterator.html">InputIterator</a>.
The value type of the <TT>EdgeIterator</TT> must be a
<TT>std::pair</TT>, where the type in the pair is an integer type. The
integers will correspond to vertices, and they must all fall in the
range of <TT>[0, n)</TT>. The <TT>value_type</TT> of the
<TT>ep_iter</TT> should be <TT>EdgeProperties</TT>.

<hr>-->

<pre>
void clear()
</pre>
Remove all of the edges and vertices from the graph.

<hr>

<pre>
void swap(adjacency_list_BC&amp; x)
</pre>
Swap the vertices, edges, and properties of this graph with the
vertices, edges, and properties of graph <tt>x</tt>.
<hr>

<P>

<H2>Non-Member Functions</H2>


<h4>Structure Access</h4>

<hr>

<pre>
std::pair&lt;vertex_iterator,&nbsp;vertex_iterator&gt;
  vertices(const adjacency_list_BC&amp; g)
</pre>
Returns an iterator-range providing access to the vertex set of graph
<tt>g</tt>.

<hr>

<pre>
std::pair&lt;edge_iterator,&nbsp;edge_iterator&gt;
  edges(const adjacency_list_BC&amp; g)
</pre>
Returns an iterator-range providing access to the edge set of graph
<tt>g</tt>.

<hr>

<pre>
std::pair&lt;adjacency_iterator,&nbsp;adjacency_iterator&gt;
  adjacent_vertices(vertex_descriptor&nbsp;u, const&nbsp;adjacency_list_BC&amp;&nbsp;g)
</pre>
Returns an iterator-range providing access to the vertices adjacent to
vertex <tt>u</tt> in graph <tt>g</tt>. For example, if <tt>u -> v</tt>
is an edge in the graph, then <tt>v</tt> will be in this iterator-range.

<hr>

<pre>
std::pair&lt;inv_adjacency_iterator,&nbsp;inv_adjacency_iterator&gt;
  inv_adjacent_vertices(vertex_descriptor&nbsp;u, const&nbsp;adjacency_list_BC&amp;&nbsp;g)
</pre>

Returns an iterator-range providing access to the vertices in graph
<tt>g</tt> to which <tt>u</tt> is adjacent. (<tt>inv</tt> is for
inverse.) For example, if <tt>v -> u</tt> is an edge in the graph,
then <tt>v</tt> will be in this iterator range. This function is only
available for bidirectional and undirected <tt>adjacency_list_BC</tt>'s.

<hr>


<pre>
std::pair&lt;out_edge_iterator,&nbsp;out_edge_iterator&gt;
  out_edges(vertex_descriptor&nbsp;u, const&nbsp;adjacency_list_BC&amp;&nbsp;g)
</pre>
Returns an iterator-range providing access to the out-edges of vertex
<tt>u</tt> in graph <tt>g</tt>. If the graph is undirected, this
iterator-range provides access to all edges incident on vertex
<tt>u</tt>. For both directed and undirected graphs, for an out-edge
<tt>e</tt>, <tt>source(e, g) == u</tt> and <tt>target(e, g) == v</tt>
where <tt>v</tt> is a vertex adjacent to <tt>u</tt>.

<hr>

<pre>
std::pair&lt;in_edge_iterator,&nbsp;in_edge_iterator&gt;
  in_edges(vertex_descriptor&nbsp;v, const&nbsp;adjacency_list_BC&amp;&nbsp;g)
</pre>
Returns an iterator-range providing access to the in-edges of vertex
<tt>v</tt> in graph <tt>g</tt>.  This operation is only available if
<TT>bidirectionalS</TT> or <TT>undirectedS</TT> was specified for the <TT>Directed</TT>
template argument. For an in-edge <tt>e</tt>, <tt>target(e, g) == v</tt>
and <tt>source(e, g) == u</tt> for some vertex <tt>u</tt> that is
adjacent to <tt>v</tt>, whether the graph is directed or undirected.
For an undirected graph, this function is the same as <tt>out_edges</tt>.

<hr>

<pre>
vertex_descriptor
  source(edge_descriptor&nbsp;e, const&nbsp;adjacency_list_BC&amp;&nbsp;g)
</pre>
Returns the source vertex of edge <tt>e</tt>.

<hr>

<pre>
vertex_descriptor
  target(edge_descriptor&nbsp;e, const&nbsp;adjacency_list_BC&amp;&nbsp;g)
</pre>
Returns the target vertex of edge <tt>e</tt>.

<hr>

<pre>
degree_size_type
  out_degree(vertex_descriptor&nbsp;u, const&nbsp;adjacency_list_BC&amp;&nbsp;g)
</pre>
Returns the number of edges leaving vertex <tt>u</tt>.

<hr>

<pre>
degree_size_type
  in_degree(vertex_descriptor&nbsp;u, const&nbsp;adjacency_list_BC&amp;&nbsp;g)
</pre>
Returns the number of edges entering vertex <tt>u</tt>. This operation
is only available if <TT>bidirectionalS</TT> or <TT>undirectedS</TT> was specified for
the <TT>Directed</TT> template parameter.
For an undirected graph, this function is the same as <tt>out_degree</tt>.

<hr>

<pre>
vertices_size_type
  num_vertices(const adjacency_list_BC&amp; g)
</pre>
Returns the number of vertices in the graph <tt>g</tt>.

<hr>

<pre>
edges_size_type
  num_edges(const adjacency_list_BC&amp; g)
</pre>
Returns the number of edges in the graph <tt>g</tt>.

<hr>


<pre>
std::pair&lt;edge_descriptor, bool&gt;
  edge(vertex_descriptor&nbsp;u, vertex_descriptor&nbsp;v,
       const&nbsp;adjacency_list_BC&amp;&nbsp;g)
</pre>
If an edge from vertex <tt>u</tt> to vertex <tt>v</tt> exists, return a pair
containing one such edge and <tt>true</tt>.  If there are no edges between
<tt>u</tt> and <tt>v</tt>, return a pair with an arbitrary edge descriptor and
<tt>false</tt>.

<hr>

<h4>Structure Modification</h4>

<hr>

<pre>
std::pair&lt;edge_descriptor, bool&gt;
  add_edge(vertex_descriptor&nbsp;u, vertex_descriptor&nbsp;v,
           adjacency_list_BC&amp; g)
</pre>
Adds edge <i>(u,v)</i> to the graph and returns the edge descriptor
for the new edge. For graphs that do not allow parallel edges, if the
edge is already in the graph then a duplicate will not be added and
the <TT>bool</TT> flag will be <TT>false</TT>. When the flag is
<TT>false</TT>, the
returned edge descriptor points to the already existing edge.

<p>
The placement of the new edge in the out-edge list is in general
unspecified, though ordering of the out-edge list can be accomplished
through the choice of <tt>OutEdgeList</tt>.

<p>
If the <TT>OutEdgeList</TT> selector is <TT>vecBC</TT> then this operation
will invalidate any <tt>out_edge_iterator</tt> for vertex
<i>u</i>. If the graph is also bidirectional then
any <tt>in_edge_iterator</tt> for <i>v</i> is also invalidated.  If
instead the graph is undirected then any <tt>out_edge_iterator</tt>
for <i>v</i> is also invalidated. If instead the graph is directed,
then <tt>add_edge()</tt> also invalidates any <tt>edge_iterator</tt>.


<hr>

<pre>
std::pair&lt;edge_descriptor,&nbsp;bool&gt;
  add_edge(vertex_descriptor&nbsp;u, vertex_descriptor&nbsp;v,
           const&nbsp;EdgeProperties&amp;&nbsp;p,
           adjacency_list_BC&amp;&nbsp;g)
</pre>
or
<pre>
std::pair&lt;edge_descriptor,&nbsp;bool&gt;
  add_edge(vertex_descriptor&nbsp;u, vertex_descriptor&nbsp;v,
           EdgeProperties&amp;&amp;&nbsp;p,
           adjacency_list_BC&amp;&nbsp;g)
</pre>
Adds edge <i>(u,v)</i> to the graph and attaches <TT>p</TT> as the
value of the edge's internal property storage.  Also see the previous
<TT>add_edge(u,v,g)</TT> member function for more details.

<hr>

<pre>
void remove_edge(vertex_descriptor u, vertex_descriptor v,
                 adjacency_list_BC&amp; g)
</pre>
Removes the edge <i>(u,v)</i> from the graph. The second version
copies / moves the edge-property of the removed edge into the passed
reference <tt>p</tt>.
<p>
This operation causes any outstanding edge descriptors or iterators
that point to edge <i>(u,v)</i> to become invalid.  In addition, if
the <TT>OutEdgeList</TT> selector is <TT>vecBC</TT> then this operation
will invalidate any iterators that point into the edge-list for vertex
<i>u</i> and also for vertex <i>v</i> in the undirected and
bidirectional case. Also, for directed graphs this invalidates any
<tt>edge_iterator</tt>.

<hr>

<pre>
void remove_edge(edge_descriptor e, adjacency_list_BC&amp; g)
</pre>
or
<pre>
void remove_edge(edge_descriptor e, EdgeProperties&amp;&nbsp;p, 
                 adjacency_list_BC&amp; g)
</pre>
Removes the edge <tt>e</tt> from the graph. The second version
copies / moves the edge-property of the removed edge into the passed
reference <tt>p</tt>. This differs from the
<tt>remove_edge(u, v, g)</tt> function in the case of a
multigraph. This <tt>remove_edge(e, g)</tt> function removes a single
edge, whereas the <tt>remove_edge(u, v, g)</tt> function removes all
edges <i>(u,v)</i>.
<p>
This operation invalidates any outstanding edge descriptors and
iterators for the same edge pointed to by descriptor <tt>e</tt>.  In
addition, this operation will invalidate any iterators that point into
the edge-list for the <tt>target(e, g)</tt>.  Also, for directed
graphs this invalidates any <tt>edge_iterator</tt> for the graph.

<hr>

<pre>
void remove_edge(out_edge_iterator iter, adjacency_list_BC&amp; g)
</pre>
or
<pre>
void remove_edge(out_edge_iterator iter, EdgeProperties&amp;&nbsp;p, 
                 adjacency_list_BC&amp; g)
</pre>
This has the same effect as <tt>remove_edge(*iter, g)</tt>. The second version
copies / moves the edge-property of the removed edge into the passed
reference <tt>p</tt>. The
difference is that this function has constant time complexity
in the case of directed graphs, whereas <tt>remove_edge(e, g)</tt>
has time complexity <i>O(E/V)</i>.

<hr>

<a name="sec:add-vertex">
<pre>
vertex_descriptor
  add_vertex(adjacency_list_BC&amp; g)
</pre>
Adds a vertex to the graph and returns the vertex descriptor for the
new vertex.
</a>

<hr>

<pre>
vertex_descriptor
  add_vertex(const&nbsp;VertexProperties&amp;&nbsp;p,
             adjacency_list_BC&amp; g)
</pre>
or
<pre>
vertex_descriptor
  add_vertex(VertexProperties&amp;&amp;&nbsp;p,
             adjacency_list_BC&amp; g)
</pre>
Adds a vertex to the graph with the specified properties (copied or moved). 
Returns the vertex descriptor for the new vertex.
</a>

<hr>

<pre>
void clear_vertex(vertex_descriptor u, adjacency_list_BC&amp; g)
</pre>
Removes all edges to and from vertex <i>u</i>. The vertex still appears
in the vertex set of the graph.
<p>
The affect on descriptor and iterator stability is the
same as that of invoking <tt>remove_edge()</tt> for all of
the edges that have <tt>u</tt> as the source or target.

<hr>

<!--<pre>
void clear_out_edges(vertex_descriptor u, adjacency_list_BC&amp; g)
</pre>
Removes all out-edges from vertex <i>u</i>. The vertex still appears
in the vertex set of the graph.
<p>
The affect on descriptor and iterator stability is the
same as that of invoking <tt>remove_edge()</tt> for all of
the edges that have <tt>u</tt> as the source.
<p>
This operation is not applicable to undirected graphs
(use <tt>clear_vertex()</tt> instead).

<hr>

<pre>
void clear_in_edges(vertex_descriptor u, adjacency_list_BC&amp; g)
</pre>
Removes all in-edges from vertex <i>u</i>. The vertex still appears
in the vertex set of the graph.
<p>
The affect on descriptor and iterator stability is the
same as that of invoking <tt>remove_edge()</tt> for all of
the edges that have <tt>u</tt> as the target.
<p>
This operation is only applicable to bidirectional graphs.

<hr>-->

<pre>
void remove_vertex(vertex_descriptor u, adjacency_list_BC&amp; g)
</pre>
or
<pre>
void remove_vertex(vertex_descriptor v, VertexProperties&amp; p,
                   adjacency_list_BC&amp; g)
</pre>
Remove vertex <i>u</i> from the vertex set of the graph. The second version
copies / moves the vertex-property of the removed vertex into the passed
reference <tt>p</tt>. It is assumed
that there are no edges to or from vertex <i>u</i> when it is removed.
One way to make sure of this is to invoke <TT>clear_vertex()</TT>
beforehand.
<p>
If the <TT>VertexList</TT> template parameter of the
<TT>adjacency_list_BC</TT> was <TT>vecBC</TT>, then all vertex
descriptors, edge descriptors, and iterators for the graph are
invalidated by this operation. The builtin
<tt>vertex_index_t</tt> property for each vertex is renumbered so that
after the operation the vertex indices still form a contiguous range
<TT>[0, num_vertices(g))</TT>. If you are using external property
storage based on the builtin vertex index, then the external storage
will need to be adjusted. Another option is to not use the builtin
vertex index, and instead use a property to add your own vertex index
property. If you need to make frequent use of the
<TT>remove_vertex()</TT> function the <TT>listS</TT> selector is a
much better choice for the <TT>VertexList</TT> template parameter.

<hr>

<h4><a name="property-map-accessors">Property Map Accessors</a></h4>

<hr>

<pre>
template &lt;class <a href="./PropertyTag.html">PropertyTag</a>&gt;
property_map&lt;adjacency_list_BC, PropertyTag&gt;::type
  get(PropertyTag, adjacency_list_BC&amp; g)

template &lt;class <a href="./PropertyTag.html">PropertyTag</a>&gt;
property_map&lt;adjacency_list_BC, Tag&gt;::const_type
  get(PropertyTag, const adjacency_list_BC&amp; g)
</pre>
Returns the property map object for the vertex property specified by
<TT>PropertyTag</TT>. The <TT>PropertyTag</TT> must match one of the
properties specified in the graph's <TT>VertexProperty</TT> template
argument.

<hr>

<pre>
template &lt;class <a href="./PropertyTag.html">PropertyTag</a>, class X&gt;
typename property_traits&lt;property_map&lt;adjacency_list_BC, PropertyTag&gt;::const_type&gt::value_type
  get(PropertyTag, const adjacency_list_BC&amp; g, X x)
</pre>
This returns the property value for <tt>x</tt>, where <tt>x</tt> is either
a vertex or edge descriptor.
<hr>

<pre>
template &lt;class <a href="./PropertyTag.html">PropertyTag</a>, class X, class Value&gt;
void put(PropertyTag, const adjacency_list_BC&amp; g, X x, const Value&amp; value)
</pre>
This sets the property value for <tt>x</tt> to
<tt>value</tt>. <tt>x</tt> is either a vertex or edge descriptor.
<tt>Value</tt> must be convertible to
<tt>typename property_traits&lt;property_map&lt;adjacency_list_BC, PropertyTag&gt;::type&gt::value_type</tt>

<hr>

<!--<pre>
template &lt;class GraphProperties, class <a href="./PropertyTag.html#GraphPropertyTag">GraphPropertyTag</a>&gt;
typename graph_property&lt;adjacency_list_BC, GraphPropertyTag&gt;::type&amp;
  get_property(adjacency_list_BC&amp; g, GraphPropertyTag);
</pre>
Return the property specified by <tt>GraphPropertyTag</tt> that is
attached to the graph object <tt>g</tt>. The <tt>graph_property</tt>
traits class is defined in <a
href="../../../boost/graph/adjacency_list_BC.hpp"><tt>boost/graph/adjacency_list_BC.hpp</tt></a>.

<hr>

<pre>
template &lt;class GraphProperties, class <a href="./PropertyTag.html#GraphPropertyTag">GraphPropertyTag</a>&gt;
const typename graph_property&lt;adjacency_list_BC, GraphPropertyTag&gt;::type&amp;
  get_property(const adjacency_list_BC&amp; g, GraphPropertyTag);
</pre>
Return the property specified by <tt>GraphPropertyTag</tt> that is
attached to the graph object <tt>g</tt>.  The <tt>graph_property</tt>
traits class is defined in <a
href="../../../boost/graph/adjacency_list_BC.hpp"><tt>boost/graph/adjacency_list_BC.hpp</tt></a>.

<hr>-->



<h4><a name="serialization">Serialization</a></h4>

<hr>

<pre>
template&lt;class <a href="../../serialization/doc/archives.html#saving_interface">SavingArchive</a>&gt;
SavingArchive&amp; operator<<(SavingArchive&amp; ar, const adjacency_list_BC&amp graph);
</pre>
Serializes the graph into the archive. Requires the vertex and edge properties of the
graph to be <a href="../../serialization/doc/index.html">Serializable</a>.
<br>
Include <a href="../../../boost/graph/adj_list_BC_serialize.hpp"><tt>boost/graph/adj_list_BC_serialize.hpp</tt></a>.
<hr>

<pre>
template&lt;class <a href="../../serialization/doc/archives.html#loading_interface">LoadingArchive</a>&gt;
LoadingArchive&amp; operator>>(LoadingArchive&amp; ar, const adjacency_list_BC&amp graph);
</pre>
Reads the graph from the archive. Requires the vertex and edge properties of the
graph to be <a href="../../serialization/doc/index.html">Serializable</a>.
<br>
Include <a href="../../../boost/graph/adj_list_BC_serialize.hpp"><tt>boost/graph/adj_list_BC_serialize.hpp</tt></a>.
<hr>


<h3>See Also</h3>

<a href="./adjacency_list_traits.html"><tt>adjacency_list_traits</tt></a>,
<a href="./property_map.html"><tt>property_map</tt></a>,
<a href="./graph_traits.html"><tt>graph_traits</tt></a>



<br>
<HR>
<TABLE>
<TR valign=top>
<TD nowrap>Copyright &copy; 2013</TD><TD>
<A HREF="http://cim.mcgill.ca/~mpersson/">Sven Mikael Persson</A>, McGill University (<A HREF="mailto:mikael.s.persson@gmail.com">mikael.s.persson@gmail.com</A>)
</TD></TR>
<TR valign=top>
<TD nowrap>Copyright &copy; 2000-2001</TD><TD>
<A href="/people/jeremy_siek.htm">Jeremy Siek</A>,
Indiana University (<A
HREF="mailto:jsiek@osl.iu.edu">jsiek@osl.iu.edu</A>)<br>
<A href="/people/liequan_lee.htm">Lie-Quan Lee</A>, Indiana University (<A HREF="mailto:llee@cs.indiana.edu">llee@cs.indiana.edu</A>)<br>
<A HREF="http://www.osl.iu.edu/~lums">Andrew Lumsdaine</A>,
Indiana University (<A
HREF="mailto:lums@osl.iu.edu">lums@osl.iu.edu</A>)
</TD></TR>
</TABLE>

</BODY>
</HTML>
<!--  LocalWords:  gif ALT OutEdgeList EdgeList VertexList html VertexProperties EdgeProperties
 -->
<!--  LocalWords:  GraphPropertyTag cpp enum ai cout endl VertexAndEdgeListGraph
 -->
<!--  LocalWords:  MutablePropertyGraph hpp const ReadablePropertyMap listS num
 -->
<!--  LocalWords:  ReadWritePropertyMap vecBC dijkstra ucs pre Adj Iter Desc ep
 -->
<!--  LocalWords:  EdgeIterator EdgePropertyIterator iter bool edge's IDs siek
 -->
<!--  LocalWords:  multigraph typename htm Univ Quan Lumsdaine
 -->
